% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/est_single_cp.R
\name{find_single_cp_std}
\alias{find_single_cp_std}
\title{Estimate a Single change point within a Given Interval}
\usage{
find_single_cp_std(F_hat, st, ed, trim, V = NULL, window_size = NULL)
}
\arguments{
\item{F_hat}{A matrix of dimension \eqn{r \times T}, representing the observed time series data with \eqn{r} variables and \eqn{T} time points.}

\item{st}{An integer specifying the start index of the interval.}

\item{ed}{An integer specifying the end index of the interval.}

\item{trim}{A positive integer specifying the trimming parameter to avoid estimating near the boundaries. Requires \code{ed - st > 2 * trim}.}

\item{V}{An optional positive-definite covariance matrix for standardising the test statistic. If \code{NULL}, a local estimate is used.}

\item{window_size}{An optional integer indicating the local window size used when estimating the covariance matrix for standardisation (only relevant if \code{V = NULL}).}
}
\value{
A data frame with one row and columns:
\describe{
\item{est.cp}{Estimated location of the change point within \code{[st, ed]}.}
\item{val}{The associated CUSUM statistic value.}
\item{st}{The interval start index.}
\item{ed}{The interval end index.}
\item{trim}{The trimming parameter used.}
}
}
\description{
This function computes a CUSUM-based statistic for detecting a single change point
within the interval \code{[st, ed]} in a multivariate time series matrix.
It compares empirical covariance matrices before and after each candidate point \eqn{k}, adjusted for long-run variance or local estimates.
}
\details{
For each candidate point \eqn{k \in (st + trim, ed - trim)}, the function computes the difference between
the empirical covariance matrices before and after \eqn{k}. The Frobenius norm (or Mahalanobis distance)
of the vectorised difference is used as a CUSUM score.

If \code{V} is supplied, it is used for standardisation. Otherwise, the function estimates a local covariance
matrix around each \eqn{k} using a moving window and applies the corresponding inverse for scaling.

Boundary points are forced to have score zero to prevent spurious maxima near edges.
}
\examples{
\dontrun{
# Example with simulated data
F_hat <- matrix(rnorm(200), nrow = 5)
find_single_cp_std(F_hat, st = 1, ed = 40, trim = 5)
}

}
